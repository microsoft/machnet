/* automatically generated by rust-bindgen 0.69.4 */

pub type MachnetRingSlot_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachnetFlow {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub src_port: u16,
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_MachnetFlow() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetFlow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetFlow>(),
        12usize,
        concat!("Size of: ", stringify!(MachnetFlow))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetFlow>(),
        4usize,
        concat!("Alignment of ", stringify!(MachnetFlow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetFlow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_ip) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetFlow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetFlow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_port) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetFlow),
            "::",
            stringify!(dst_port)
        )
    );
}
pub type MachnetFlow_t = MachnetFlow;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct MachnetChannelDataCtx {
    pub stats_ofs: usize,
    pub ctrl_sq_ring_ofs: usize,
    pub ctrl_cq_ring_ofs: usize,
    pub machnet_ring_ofs: usize,
    pub app_ring_ofs: usize,
    pub buf_ring_ofs: usize,
    pub buffer_index_table_ofs: usize,
    pub buf_pool_ofs: usize,
    pub buf_pool_mask: usize,
    pub buf_size: u32,
    pub buf_mss: u32,
}
#[test]
fn bindgen_test_layout_MachnetChannelDataCtx() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetChannelDataCtx> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetChannelDataCtx>(),
        128usize,
        concat!("Size of: ", stringify!(MachnetChannelDataCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetChannelDataCtx>(),
        64usize,
        concat!("Alignment of ", stringify!(MachnetChannelDataCtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats_ofs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(stats_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrl_sq_ring_ofs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(ctrl_sq_ring_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrl_cq_ring_ofs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(ctrl_cq_ring_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).machnet_ring_ofs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(machnet_ring_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_ring_ofs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(app_ring_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_ring_ofs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(buf_ring_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_index_table_ofs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(buffer_index_table_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_pool_ofs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(buf_pool_ofs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_pool_mask) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(buf_pool_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_mss) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelDataCtx),
            "::",
            stringify!(buf_mss)
        )
    );
}
pub type MachnetChannelDataCtx_t = MachnetChannelDataCtx;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct MachnetChannelCtrlCtx {
    pub req_id: usize,
}
#[test]
fn bindgen_test_layout_MachnetChannelCtrlCtx() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetChannelCtrlCtx> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetChannelCtrlCtx>(),
        64usize,
        concat!("Size of: ", stringify!(MachnetChannelCtrlCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetChannelCtrlCtx>(),
        64usize,
        concat!("Alignment of ", stringify!(MachnetChannelCtrlCtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtrlCtx),
            "::",
            stringify!(req_id)
        )
    );
}
pub type MachnetChannelCtrlCtx_t = MachnetChannelCtrlCtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachnetChannelAppBufferCache {
    pub count: u32,
    pub indices: [MachnetRingSlot_t; 64usize],
}
#[test]
fn bindgen_test_layout_MachnetChannelAppBufferCache() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetChannelAppBufferCache> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetChannelAppBufferCache>(),
        260usize,
        concat!("Size of: ", stringify!(MachnetChannelAppBufferCache))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetChannelAppBufferCache>(),
        4usize,
        concat!("Alignment of ", stringify!(MachnetChannelAppBufferCache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelAppBufferCache),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indices) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelAppBufferCache),
            "::",
            stringify!(indices)
        )
    );
}
pub type MachnetChannelAppBufferCache_t = MachnetChannelAppBufferCache;
#[doc = " The `MachnetChannelCtx' holds all the metadata information (context) of an\n Machnet Channel.\n\n It is always located at the beginning of the shared memory area."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct MachnetChannelCtx {
    pub magic: u32,
    pub version: u16,
    pub size: u64,
    pub name: [::std::os::raw::c_char; 256usize],
    pub __bindgen_padding_0: [u64; 6usize],
    pub ctrl_ctx: MachnetChannelCtrlCtx_t,
    pub data_ctx: MachnetChannelDataCtx_t,
    pub app_buffer_cache: MachnetChannelAppBufferCache_t,
}
#[test]
fn bindgen_test_layout_MachnetChannelCtx() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetChannelCtx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetChannelCtx>(),
        832usize,
        concat!("Size of: ", stringify!(MachnetChannelCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetChannelCtx>(),
        64usize,
        concat!("Alignment of ", stringify!(MachnetChannelCtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrl_ctx) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(ctrl_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_ctx) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(data_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_buffer_cache) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetChannelCtx),
            "::",
            stringify!(app_buffer_cache)
        )
    );
}
#[doc = " The `MachnetChannelCtx' holds all the metadata information (context) of an\n Machnet Channel.\n\n It is always located at the beginning of the shared memory area."]
pub type MachnetChannelCtx_t = MachnetChannelCtx;
#[doc = " @brief Descriptor for SG data that constitute a message.\n\n This structure resembles `struct iovec` (check writev(2))."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachnetIovec {
    #[doc = "< Pointer to the beginning of the SG data."]
    pub base: *mut ::std::os::raw::c_void,
    #[doc = "< Length of the SG data."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_MachnetIovec() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetIovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetIovec>(),
        16usize,
        concat!("Size of: ", stringify!(MachnetIovec))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetIovec>(),
        8usize,
        concat!("Alignment of ", stringify!(MachnetIovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetIovec),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetIovec),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " @brief Descriptor for SG data that constitute a message.\n\n This structure resembles `struct iovec` (check writev(2))."]
pub type MachnetIovec_t = MachnetIovec;
#[doc = " @brief Descriptor for a message.\n\n This structure resembles `struct msghdr`, but with a few adjustments:\n - `msg_size` is the total size of the message payload.\n - `peer_addr` is the address of the network peer that is the recipient or\n    sender of the message (depending on the direction).\n - `msg_iov` is a vector of `msg_iovlen` `MachnetIovec_t` structures.\n - `msg_iovlen` is the number of `MachnetIovec_t` structures in `msg_iov`.\n - `flags` is the message flags."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachnetMsgHdr {
    pub msg_size: u32,
    pub flow_info: MachnetFlow_t,
    pub msg_iov: *mut MachnetIovec_t,
    pub msg_iovlen: usize,
    pub flags: u16,
}
#[test]
fn bindgen_test_layout_MachnetMsgHdr() {
    const UNINIT: ::std::mem::MaybeUninit<MachnetMsgHdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MachnetMsgHdr>(),
        40usize,
        concat!("Size of: ", stringify!(MachnetMsgHdr))
    );
    assert_eq!(
        ::std::mem::align_of::<MachnetMsgHdr>(),
        8usize,
        concat!("Alignment of ", stringify!(MachnetMsgHdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetMsgHdr),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetMsgHdr),
            "::",
            stringify!(flow_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetMsgHdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetMsgHdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MachnetMsgHdr),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Descriptor for a message.\n\n This structure resembles `struct msghdr`, but with a few adjustments:\n - `msg_size` is the total size of the message payload.\n - `peer_addr` is the address of the network peer that is the recipient or\n    sender of the message (depending on the direction).\n - `msg_iov` is a vector of `msg_iovlen` `MachnetIovec_t` structures.\n - `msg_iovlen` is the number of `MachnetIovec_t` structures in `msg_iov`.\n - `flags` is the message flags."]
pub type MachnetMsgHdr_t = MachnetMsgHdr;
extern "C" {
    #[doc = " @brief Initializes the Machnet library for the application, which is used\n to interact with the Machnet service on the machine.\n\n @return 0 on success, -1 on failure."]
    pub fn machnet_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief NOT part of the public API.\n\n This is a helper function used to bind to a shared memory segment from\n the application. The Machnet controller is going to hand over an open file\n descriptor to the appropriate shared memory segment. Internally, this\n function is resolving the size of the shared memory segment, and memory maps\n it to the process address space of the caller (application).\n\n @param shm_fd Open file descriptor for the shared memory segment.\n @param channel_size Pointer to a `size_t` variable that will be filled with\n the size of the channel. This is optional and can be `NULL`.\n @return A pointer to the mapped channel on success, `NULL` otherwise."]
    pub fn machnet_bind(
        shm_fd: ::std::os::raw::c_int,
        channel_size: *mut usize,
    ) -> *mut MachnetChannelCtx_t;
}
extern "C" {
    #[doc = " @brief Creates a new channel to the Machnet controller and binds to it. A\n channel is a logical entity between an application and the Machnet service.\n\n @return A pointer to the channel context on success, NULL otherwise."]
    pub fn machnet_attach() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Listens for incoming messages on a specific IP and port.\n @param[in] channel The channel associated to the listener.\n @param[in] ip The local IP address to listen on.\n @param[in] port The local port to listen on.\n @return 0 on success, -1 on failure."]
    pub fn machnet_listen(
        channel_ctx: *mut ::std::os::raw::c_void,
        local_ip: *const ::std::os::raw::c_char,
        port: u16,
        protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creates a new connection to a remote peer.\n @param[in] channel     The channel associated with the connection.\n @param[in] local_ip    The local IP address.\n @param[in] remote_ip   The remote IP address.\n @param[in] remote_port The remote port.\n @param[out] flow       A pointer to a `MachnetFlow_t` structure that will be\n                        filled by the function upon success.\n @return  0 on success, -1 on failure. `flow` is filled with the flow\n information on success."]
    pub fn machnet_connect(
        channel_ctx: *mut ::std::os::raw::c_void,
        local_ip: *const ::std::os::raw::c_char,
        remote_ip: *const ::std::os::raw::c_char,
        remote_port: u16,
        flow: *mut MachnetFlow_t,
        protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enqueue one message for transmission to a remote peer over the network.\n\n @param[in] channel_ctx The Machnet channel context\n @param[in] flow The pre-created flow to the remote peer\n @param[in] buf The data buffer to send to the remote peer\n @param[in] len The length of the data buffer in bytes"]
    pub fn machnet_send(
        channel_ctx: *const ::std::os::raw::c_void,
        flow: MachnetFlow_t,
        buf: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function enqueues one message for transmission to a remote peer over\n the network. The application needs to provide the destination's (remote\n peer) address. Machnet is responsible for end-to-end encrypted, reliable\n delivery of each message to the relevant receiver. This function supports\n SG collection of a message's buffers from the application's address\n space.\n\n @param[in] channel_ctx        The Machnet channel context\n @param[in] msghdr             An `MachnetMsgHdr' descriptor\n @return                   0 on success, -1 on failure"]
    pub fn machnet_sendmsg(
        channel_ctx: *const ::std::os::raw::c_void,
        msghdr: *const MachnetMsgHdr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function sends one or more messages to a remote peer over the network.\n The application needs to provide the destination's (remote peer) address.\n Machnet is responsible for end-to-end encrypted, reliable delivery of each\n message to the relevant receiver. This function supports SG collection of a\n message's buffers from the application's address space.\n\n @param[in] channel_ctx        The Machnet channel context\n @param[in] msghdr_iovec       An array of `MachnetMsgHdr' descriptors, each\n one describing a standalone TX message.\n @param[in] vlen               Length of the `msghdr_iovec' array (number of\n                               messages to be sent).\n @return                       # of messages sent."]
    pub fn machnet_sendmmsg(
        channel_ctx: *const ::std::os::raw::c_void,
        msghdr_iovec: *const MachnetMsgHdr_t,
        vlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a pending message from some remote peer over the network.\n\n @param[in] channel_ctx The Machnet channel context\n @param[out] buf The data buffer to receive the message\n @param[in] len The length of \\p buf in bytes\n @param[out] flow The flow information of the sender\n\n @return 0 if no message is available, -1 on failure, otherwise the number of\n bytes received."]
    pub fn machnet_recv(
        channel_ctx: *const ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        flow: *mut MachnetFlow_t,
    ) -> isize;
}
extern "C" {
    #[doc = " This function receives a pending message (destined to the application) from\n the Machnet Channel. The application is responsible from providing an\n appropriate msghdr, which describes the locations of the buffers (SG is\n supported) to which the message should be copied to. The sender's network\n information can be found in the `flow_info` field of the msghdr.\n\n @param[in] ctx                The Machnet channel context\n @param[in, out] msghdr        An `MachnetMsgHdr' descriptor. The application\n                               needs to fill in the `msg_iov` and `msg_iovlen`\n                               members, which describe the locations of the\n                               buffers to which the message should be copied\n                               to. The `flow_info` member is set by Machnet to\n                               indicate the flow that the message belongs to.\n @return                       0 if no pending message, 1 if a message is\n                               received, -1 on failure"]
    pub fn machnet_recvmsg(
        channel_ctx: *const ::std::os::raw::c_void,
        msghdr: *mut MachnetMsgHdr_t,
    ) -> ::std::os::raw::c_int;
}
